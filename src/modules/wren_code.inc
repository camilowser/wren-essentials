// Generated automatically from src/modules/*.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"// FIXME: Add cache.\n"
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var mirror = ObjectMirror\n"
"    if (reflectee is Class) mirror = ClassMirror\n"
"    if (reflectee is Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.new_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, methodName)\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  classMirror {\n"
"    if (_classMirror == null) _classMirror = Mirror.reflect(_reflectee.type)\n"
"    return _classMirror\n"
"  }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { classMirror.hasMethod(signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static allAttributes(reflectee)\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"    _moduleMirror = null\n"
"\n"
"    _methods = ClassMirror.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(reflectee)\n"
"    return attr != null ? attr.self : null\n"
"  }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"\n"
"  methodNames { _methodNames }\n"
"  methodMirrors { _methodMirrors }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static methodAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { FiberMirror.lineAt_(reflectee, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { FiberMirror.methodAt_(reflectee, stackTraceIndex) }\n"
"  stackFramesCount          { FiberMirror.stackFramesCount_(reflectee) }\n"
"\n"
"  stackTrace {\n"
"    var reflectee = this.reflectee\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(reflectee)\n"
"    if (reflectee == Fiber.current) stackFramesCount = stackFramesCount - 1\n"
"    return StackTrace.new_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static module_(method)\n"
"  foreign static signature_(method)\n"
"\n"
"  construct new_(method/*, classMirror, signature*/) {\n"
"    _method = method\n"
"  }\n"
"\n"
"//  classMirror { Mirror.reflect(MethodMirror.class_(_method)) }\n"
"  moduleMirror { ModuleMirror.fromModule_(MethodMirror.module_(_method)) }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(_class)\n"
"    var methods = attr != null ? attr.methods : null\n"
"    return methods != null ? methods[signature] : null\n"
"  }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static fromModule_(module) {\n"
"    return ModuleMirror.new_(module)\n"
"  }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return ModuleMirror.fromModule_(module)\n"
"  }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"\n"
"class StackTrace {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"    for (i in 0...stackFramesCount) {\n"
"      _stackTrace.add(StackTraceFrame.new_(fiber, i))\n"
"    }\n"
"  }\n"
"  \n"
"  static new(fiber) {\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(fiber)\n"
"\n"
"    return new_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  frames { _stackTrace }\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(fiber, stackFramesIndex) {\n"
"    _line = FiberMirror.lineAt_(fiber, stackFramesIndex)\n"
"    _methodMirror = MethodMirror.new_(FiberMirror.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { _line }\n"
"  methodMirror { _methodMirror }\n"
"\n"
"  // toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"  toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((LOWERCASE_A..LOWERCASE_Z).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((UPPERCASE_A..UPPERCASE_Z).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static capitalize(s) {\n"
"        if (s.isEmpty) return \"\"\n"
"        if (s.count == 1) return Strings.upcase(s)\n"
"        return Strings.upcase(s[0]) + s[1..-1]\n"
"    }\n"
"    static titlecase(s) {\n"
"        return s.split(\" \").map {|w| capitalize(downcase(w)) }.join(\" \")\n"
"    }\n"
"\n"
"    /************************************************************************\n"
"     * Adapting the Tcl `string match` command\n"
"     *\n"
"     * Special characters that can appear in a pattern:\n"
"        *\n"
"            Matches any sequence of characters in string, including a null\n"
"            string.\n"
"\n"
"        ?\n"
"            Matches any single character in string.\n"
"\n"
"        [chars]\n"
"            Matches any character in the set given by chars. If a sequence\n"
"            of the form x-y appears in chars, then any character between x\n"
"            and y, inclusive, will match. Ranges can be forward ([a-z]) or\n"
"            backward ([z-a]).\n"
"\n"
"            In somewhat odd behaviour, patterns ending with unclosed\n"
"            bracket expressions will match successfully:\n"
"                Strings.globMatch(\"a\", \"[a]\")   // expect: true\n"
"                Strings.globMatch(\"a\", \"[a\")    // expect: true\n"
"\n"
"            Additionally, \"]\" can appear inside a bracket expression\n"
"            only as the end of a range.\n"
"\n"
"            Empty bracket expressions are always invalid.\n"
"\n"
"        \\\\x\n"
"            Matches the single character x. This provides a way of\n"
"            avoiding the special interpretation of the characters *?[]\\\\ in\n"
"            pattern. In a wren string, the backslash itself must be escaped:\n"
"                Strings.globMatch(\"a*b\", \"a\\\\*b\")   // expect: true\n"
"\n"
"            Use raw strings to reduce the number of backslashes.\n"
"     *\n"
"     */\n"
"    static globMatch(string, pattern) {\n"
"        return globMatch_(\n"
"            string,\n"
"            string.count,\n"
"            pattern,\n"
"            pattern.count\n"
"        )\n"
"    }\n"
"\n"
"    foreign static globMatch_(string, strLen, pattern, ptnLen)\n"
"}\n"
"\n"
"var LOWERCASE_A = \"a\".bytes[0]\n"
"var LOWERCASE_Z = \"z\".bytes[0]\n"
"var UPPERCASE_A = \"A\".bytes[0]\n"
"var UPPERCASE_Z = \"Z\".bytes[0]\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* jsonModuleSource =
"// Extracted from https://github.com/domeengine/dome/blob/develop/src/modules/json.wren\n"
"\n"
"class JsonOptions {\n"
"  static nil { 0 }\n"
"  static escapeSlashes { 1 }\n"
"  static abortOnError { 2 }\n"
"  static checkCircular { 4 }\n"
"\n"
"  static contains(options, option) {\n"
"    return ((options & option) != JsonOptions.nil)\n"
"  }\n"
"}\n"
"\n"
"class JsonError {\n"
"  line { _line }\n"
"  position { _position }\n"
"  message { _message }\n"
"  found { _found }\n"
"\n"
"  construct new(line, pos, message, found) {\n"
"    _line = line\n"
"    _position = pos\n"
"    _message = message\n"
"    _found = found\n"
"  }\n"
"\n"
"  static empty() {\n"
"    return JsonError.new(0, 0, \"\", false)\n"
"  }\n"
"}\n"
"\n"
"class JsonStream {\n"
"  foreign stream_begin(value)\n"
"  foreign stream_end()\n"
"  foreign next\n"
"  foreign value\n"
"  foreign error_message\n"
"  foreign lineno\n"
"  foreign pos\n"
"  foreign static escapechar(value, options)\n"
"\n"
"  namespace { \"wren-essentials.json:\" }\n"
"  isNull { namespace + \"JSON_NULL\" }\n"
"  isString { namespace + \"JSON_STRING\" }\n"
"  isNumeric { namespace + \"JSON_NUMBER\" }\n"
"  isBoolTrue { namespace + \"JSON_TRUE\" }\n"
"  isBoolFalse { namespace + \"JSON_FALSE\" }\n"
"  isArray { namespace + \"JSON_ARRAY\" }\n"
"  isArrayEnd { namespace + \"JSON_ARRAY_END\" }\n"
"  isObject { namespace + \"JSON_OBJECT\" }\n"
"  isObjectEnd { namespace + \"JSON_OBJECT_END\" }\n"
"  isDone { namespace + \"JSON_DONE\" }\n"
"  isError { namespace + \"JSON_ERROR\" }\n"
"  isInit { namespace + \"JSON_INIT\" }\n"
"\n"
"  result { _result }\n"
"  error { _error }\n"
"  options { _options }\n"
"  raw { _raw }\n"
"\n"
"  construct new(raw, options) {\n"
"    _result = {}\n"
"    _error = JsonError.empty()\n"
"    _lastEvent = isInit\n"
"    _raw = raw\n"
"    _options = options\n"
"  }\n"
"\n"
"  begin() {\n"
"    stream_begin(_raw)\n"
"    _result = process(next)\n"
"  }\n"
"\n"
"  end() {\n"
"    stream_end()\n"
"  }\n"
"\n"
"  process(event) {\n"
"    _lastEvent = event\n"
"\n"
"    if (event == isError) {\n"
"      _error = JsonError.new(lineno, pos, error_message, true)\n"
"      if (JsonOptions.contains(_options, JsonOptions.abortOnError)) {\n"
"        end()\n"
"        Fiber.abort(\"JSON error - line %(lineno) pos %(pos): %(error_message)\")\n"
"      }\n"
"      return\n"
"    }\n"
"\n"
"    if (event == isDone) {\n"
"      return\n"
"    }\n"
"\n"
"    if (event == isBoolTrue || event == isBoolFalse) {\n"
"      return (event == isBoolTrue)\n"
"    }\n"
"\n"
"    if (event == isNumeric) {\n"
"      return Num.fromString(this.value)\n"
"    }\n"
"\n"
"    if (event == isString) {\n"
"      return this.value\n"
"    }\n"
"\n"
"    if (event == isNull) {\n"
"      return null\n"
"    }\n"
"\n"
"    if (event == isArray) {\n"
"      var elements = []\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == isArrayEnd) {\n"
"          break\n"
"        }\n"
"        elements.add(process(event))\n"
"      }\n"
"      return elements\n"
"    }\n"
"\n"
"    if (event == isObject) {\n"
"      var elements = {}\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == isObjectEnd) {\n"
"            break\n"
"        }\n"
"        elements[this.value] = process(next)\n"
"      }\n"
"      return elements\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"// protocol for Json encodable values\n"
"// So they can override how to\n"
"class JsonEncodable {\n"
"  toJson {this.toString}\n"
"  toJSON {toJson}\n"
"}\n"
"\n"
"class JsonEncoder {\n"
"  construct new(options) {\n"
"    _options = options\n"
"    _circularStack = JsonOptions.contains(options, JsonOptions.checkCircular) ? [] : null\n"
"  }\n"
"\n"
"  isCircle(value) {\n"
"    if (_circularStack == null) {\n"
"      return false\n"
"    }\n"
"    return _circularStack.any { |v| Object.same(value, v) }\n"
"  }\n"
"\n"
"  push(value) {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.add(value)\n"
"    }\n"
"  }\n"
"  pop() {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.removeAt(-1)\n"
"    }\n"
"  }\n"
"\n"
"  encode(value) {\n"
"    if (isCircle(value)) {\n"
"      Fiber.abort(\"Circular JSON\")\n"
"    }\n"
"\n"
"    // Loosely based on https://github.com/brandly/wren-json/blob/master/json.wren\n"
"    if (value is Num || value is Bool || value is Null) {\n"
"      return value.toString\n"
"    }\n"
"\n"
"    if (value is String) {\n"
"      // Escape special characters\n"
"      var substrings = []\n"
"      for (char in value) {\n"
"        substrings.add(JsonStream.escapechar(char, _options))\n"
"      }\n"
"\n"
"      // Compile error if you use normal escaping sequence\n"
"      // so we have to use bytes to string method for the single \" char\n"
"      return String.fromByte(0x22) + substrings.join(\"\") + String.fromByte(0x22)\n"
"    }\n"
"\n"
"    if (value is List) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (item in value) {\n"
"        substrings.add(encode(item))\n"
"      }\n"
"      pop()\n"
"      return \"[\" + substrings.join(\",\") + \"]\"\n"
"    }\n"
"\n"
"    if (value is Map) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (key in value.keys) {\n"
"        var keyValue = this.encode(value[key])\n"
"        var encodedKey = this.encode(key)\n"
"        substrings.add(\"%(encodedKey):%(keyValue)\")\n"
"      }\n"
"      pop()\n"
"      return \"{\" + substrings.join(\",\") + \"}\"\n"
"    }\n"
"\n"
"    if (value is JsonEncodable) {\n"
"      return value.toJson\n"
"    }\n"
"\n"
"    // Default behaviour is to invoke the toString method\n"
"    return value.toString\n"
"  }\n"
"}\n"
"\n"
"class Json {\n"
"\n"
"  static encode(value, options) { JsonEncoder.new(options).encode(value) }\n"
"\n"
"  static encode(value) {\n"
"    return Json.encode(value, JsonOptions.abortOnError)\n"
"  }\n"
"\n"
"  static parse(value) {\n"
"    return Json.decode(value)\n"
"  }\n"
"\n"
"  static stringify(value) {\n"
"    return Json.encode(value)\n"
"  }\n"
"\n"
"  static decode(value, options) {\n"
"    var stream = JsonStream.new(value, options)\n"
"    stream.begin()\n"
"\n"
"    var result = stream.result\n"
"    if (stream.error.found) {\n"
"      result = stream.error\n"
"    }\n"
"\n"
"    stream.end()\n"
"    return result\n"
"  }\n"
"\n"
"  static decode(value) {\n"
"    return Json.decode(value, JsonOptions.abortOnError)\n"
"  }\n"
"}\n"
"\n"
"var JSON = Json\n"
"var JSONOptions = JsonOptions\n"
"var JSONError = JsonError\n"
"var JSONEncodable = JsonEncodable";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

