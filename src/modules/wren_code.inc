// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* jsonModuleSource =
"// Extracted from https://github.com/domeengine/dome/blob/develop/src/modules/json.wren\n"
"// Loosely based on https://github.com/brandly/wren-json/blob/master/json.wren\n"
"\n"
"class JSONOptions {\n"
"  #description = \"No options\"\n"
"  static nil { 0 }\n"
"\n"
"  #description = \"Escape `/` char\"\n"
"  static escapeSolidus { 1 }\n"
"\n"
"  #description = \"Abort on Error\"\n"
"  static abortOnError { 2 }\n"
"\n"
"  #description = \"Avoid infinite recursion\"\n"
"  static checkCircular { 4 }\n"
"\n"
"  #description = \"true if `option` is within `options`\"\n"
"  static contains(options, option) {\n"
"    return ((options & option) != JSONOptions.nil)\n"
"  }\n"
"}\n"
"\n"
"class JSONError {\n"
"  line { _line }\n"
"  position { _position }\n"
"  message { _message }\n"
"  found { _found }\n"
"\n"
"  construct new(line, pos, message, found) {\n"
"    _line = line\n"
"    _position = pos\n"
"    _message = message\n"
"    _found = found\n"
"  }\n"
"\n"
"  construct abort(message) {\n"
"    var error = JSONError.new(0, 0, message, false)\n"
"    Fiber.abort(error)\n"
"  }\n"
"\n"
"  static empty() {\n"
"    return JSONError.new(0, 0, \"\", false)\n"
"  }\n"
"\n"
"  toString {\"[Error] JSON | line: %(line) | pos: %(position) | %(message)\"}\n"
"}\n"
"\n"
"// pdjson.h:\n"
"\n"
"// enum json_type {\n"
"//     JSON_ERROR = 1, JSON_DONE,\n"
"//     JSON_OBJECT, JSON_OBJECT_END, JSON_ARRAY, JSON_ARRAY_END,\n"
"//     JSON_STRING, JSON_NUMBER, JSON_TRUE, JSON_FALSE, JSON_NULL\n"
"// };\n"
"\n"
"class Token {\n"
"  static isError { 1 }\n"
"  static isDone { 2 }\n"
"  static isObject { 3 }\n"
"  static isObjectEnd { 4 }\n"
"  static isArray { 5 }\n"
"  static isArrayEnd { 6 }\n"
"  static isString { 7 }\n"
"  static isNumeric { 8 }\n"
"  static isBoolTrue { 9 }\n"
"  static isBoolFalse { 10 }\n"
"  static isNull { 11 }\n"
"}\n"
"\n"
"class JSONStream {\n"
"  foreign stream_begin(value)\n"
"  foreign stream_end()\n"
"  foreign next\n"
"  foreign value\n"
"  foreign error_message\n"
"  foreign lineno\n"
"  foreign pos\n"
"\n"
"  result { _result }\n"
"  error { _error }\n"
"  options { _options }\n"
"  raw { _raw }\n"
"\n"
"  construct new(raw, options) {\n"
"    _result = {}\n"
"    _error = JSONError.empty()\n"
"    _lastEvent = null\n"
"    _raw = raw\n"
"    _options = options\n"
"  }\n"
"\n"
"  begin() {\n"
"    stream_begin(_raw)\n"
"    _result = process(next)\n"
"  }\n"
"\n"
"  end() {\n"
"    stream_end()\n"
"  }\n"
"\n"
"  process(event) {\n"
"    _lastEvent = event\n"
"\n"
"    if (event == Token.isError) {\n"
"      _error = JSONError.new(lineno, pos, error_message, true)\n"
"      if (JSONOptions.contains(_options, JSONOptions.abortOnError)) {\n"
"        end()\n"
"        Fiber.abort(_error)\n"
"      }\n"
"      return\n"
"    }\n"
"\n"
"    if (event == Token.isDone) {\n"
"      return\n"
"    }\n"
"\n"
"    if (event == Token.isBoolTrue || event == Token.isBoolFalse) {\n"
"      return (event == Token.isBoolTrue)\n"
"    }\n"
"\n"
"    if (event == Token.isNumeric) {\n"
"      return Num.fromString(this.value)\n"
"    }\n"
"\n"
"    if (event == Token.isString) {\n"
"      return this.value\n"
"    }\n"
"\n"
"    if (event == Token.isNull) {\n"
"      return null\n"
"    }\n"
"\n"
"    if (event == Token.isArray) {\n"
"      var elements = []\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == Token.isArrayEnd) {\n"
"          break\n"
"        }\n"
"        elements.add(process(event))\n"
"      }\n"
"      return elements\n"
"    }\n"
"\n"
"    if (event == Token.isObject) {\n"
"      var elements = {}\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == Token.isObjectEnd) {\n"
"            break\n"
"        }\n"
"        elements[this.value] = process(next)\n"
"      }\n"
"      return elements\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"// Protocol for JSON encodable values\n"
"// prefer implementing toJSON method instead of relying on toString\n"
"class JSONEncodable {\n"
"  toJSON {this.toString}\n"
"}\n"
"\n"
"class JSONEscapeChars {\n"
"  static hexchars {[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]}\n"
"\n"
"  static toHex(byte) {\n"
"    var hex = \"\"\n"
"    while (byte > 0) {\n"
"      var c = byte % 16\n"
"      hex = hexchars[c] + hex\n"
"      byte = byte >> 4\n"
"    }\n"
"    return hex\n"
"  }\n"
"  \n"
"  static lpad(s, count, with) {\n"
"    while (s.count < count) {\n"
"      s = \"%(with)%(s)\"\n"
"    }\n"
"    return s\n"
"  }\n"
"\n"
"  static escape(text) {\n"
"    var substrings = []\n"
"    // Escape special characters\n"
"    for (char in text) {\n"
"      if (char == \"\\\"\") {\n"
"        substrings.add(\"\\\\\\\"\")\n"
"      } else if (char == \"\\\\\") {\n"
"        substrings.add(\"\\\\\\\\\")\n"
"      } else if (char == \"\\b\") {\n"
"        substrings.add(\"\\\\b\")\n"
"      } else if (char == \"\\f\") {\n"
"        substrings.add(\"\\\\f\")\n"
"      } else if (char == \"\\n\") {\n"
"        substrings.add(\"\\\\n\")\n"
"      } else if (char == \"\\r\") {\n"
"        substrings.add(\"\\\\r\")\n"
"      } else if (char == \"\\t\") {\n"
"        substrings.add(\"\\\\t\")\n"
"      } else if (char.bytes[0] <= 0x1f) {\n"
"        // Control characters!\n"
"        var byte = char.bytes[0]\n"
"        var hex = lpad(toHex(byte), 4, \"0\")\n"
"        substrings.add(\"\\\\u\" + hex)\n"
"      } else {\n"
"        substrings.add(char)\n"
"      }\n"
"    }\n"
"    return \"\\\"\" + substrings.join(\"\") + \"\\\"\"\n"
"  }\n"
"\n"
"  static escape(text, options) {\n"
"    var string = text\n"
"\n"
"    // Escape / (solidus, slash)\n"
"    // https://stackoverflow.com/a/9735430\n"
"    // The feature of the slash escape allows JSON to be embedded in HTML (as SGML) and XML.\n"
"    // https://www.w3.org/TR/html4/appendix/notes.html#h-B.3.2\n"
"    // This is optional escaping. Disabled by default.\n"
"    // use JSONOptions.escapeSolidus option to enable it\n"
"    if (JSONOptions.contains(options, JSONOptions.escapeSolidus)) {\n"
"      var substrings = []\n"
"      for (char in string) {\n"
"        if (char == \"/\") {\n"
"          substrings.add(\"\\\\/\")\n"
"        } else {\n"
"          substrings.add(char)\n"
"        }\n"
"      }\n"
"      string = substrings.join(\"\")\n"
"    }\n"
"\n"
"    return escape(string)\n"
"  }\n"
"}\n"
"\n"
"class JSONEncoder {\n"
"  construct new(options) {\n"
"    _options = options\n"
"    _circularStack = JSONOptions.contains(options, JSONOptions.checkCircular) ? [] : null\n"
"  }\n"
"\n"
"  isCircle(value) {\n"
"    if (_circularStack == null) {\n"
"      return false\n"
"    }\n"
"    return _circularStack.any { |v| Object.same(value, v) }\n"
"  }\n"
"\n"
"  push(value) {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.add(value)\n"
"    }\n"
"  }\n"
"  pop() {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.removeAt(-1)\n"
"    }\n"
"  }\n"
"\n"
"  encode(value) {\n"
"    if (isCircle(value)) {\n"
"      JSONError.abort(\"Circular JSON\")\n"
"    }\n"
"\n"
"    if (value is Num || value is Bool || value is Null) {\n"
"      return value.toString\n"
"    }\n"
"\n"
"    if (value is String) {\n"
"      // Escape special characters\n"
"      return JSONEscapeChars.escape(value, _options)\n"
"    }\n"
"\n"
"    if (value is List) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (item in value) {\n"
"        substrings.add(encode(item))\n"
"      }\n"
"      pop()\n"
"      return \"[\" + substrings.join(\",\") + \"]\"\n"
"    }\n"
"\n"
"    if (value is Map) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (key in value.keys) {\n"
"        var keyValue = this.encode(value[key])\n"
"        var encodedKey = this.encode(key)\n"
"        substrings.add(\"%(encodedKey):%(keyValue)\")\n"
"      }\n"
"      pop()\n"
"      return \"{\" + substrings.join(\",\") + \"}\"\n"
"    }\n"
"\n"
"    // Value is not a primitive\n"
"    // Check the protocol first\n"
"    if (value is JSONEncodable) {\n"
"      return value.toJSON\n"
"    }\n"
"\n"
"    // Default behaviour is to invoke the toString method\n"
"    return value.toString\n"
"  }\n"
"}\n"
"\n"
"class JSON {\n"
"\n"
"  static defaultOptions {JSONOptions.abortOnError | JSONOptions.checkCircular}\n"
"\n"
"  static encode(value, options) { JSONEncoder.new(options).encode(value) }\n"
"\n"
"  static encode(value) {\n"
"    return JSON.encode(value, defaultOptions)\n"
"  }\n"
"\n"
"  static decode(value, options) {\n"
"    var stream = JSONStream.new(value, options)\n"
"    stream.begin()\n"
"\n"
"    var result = stream.result\n"
"    if (stream.error.found) {\n"
"      result = stream.error\n"
"    }\n"
"\n"
"    stream.end()\n"
"    return result\n"
"  }\n"
"\n"
"  static decode(value) {\n"
"    return JSON.decode(value, defaultOptions)\n"
"  }\n"
"\n"
"  #alias(encode)\n"
"\n"
"  static stringify(value, options) {\n"
"    return JSON.encode(value, options)\n"
"  }\n"
"\n"
"  static stringify(value) {\n"
"    return JSON.encode(value)\n"
"  }\n"
"\n"
"  #alias(decode)\n"
"\n"
"  static parse(value, options) {\n"
"    return JSON.decode(value, options)\n"
"  }\n"
"\n"
"  static parse(value) {\n"
"    return JSON.decode(value)\n"
"  }\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"// FIXME: Add cache.\n"
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var mirror = ObjectMirror\n"
"    if (reflectee is Class) mirror = ClassMirror\n"
"    if (reflectee is Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.new_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, methodName)\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  classMirror {\n"
"    if (_classMirror == null) _classMirror = Mirror.reflect(_reflectee.type)\n"
"    return _classMirror\n"
"  }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { classMirror.hasMethod(signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static allAttributes(reflectee)\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"    _moduleMirror = null\n"
"\n"
"    _methods = ClassMirror.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(reflectee)\n"
"    return attr != null ? attr.self : null\n"
"  }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"\n"
"  methodNames { _methodNames }\n"
"  methodMirrors { _methodMirrors }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static methodAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { FiberMirror.lineAt_(reflectee, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { FiberMirror.methodAt_(reflectee, stackTraceIndex) }\n"
"  stackFramesCount          { FiberMirror.stackFramesCount_(reflectee) }\n"
"\n"
"  stackTrace {\n"
"    var reflectee = this.reflectee\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(reflectee)\n"
"    if (reflectee == Fiber.current) stackFramesCount = stackFramesCount - 1\n"
"    return StackTrace.new_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static module_(method)\n"
"  foreign static signature_(method)\n"
"\n"
"  construct new_(method/*, classMirror, signature*/) {\n"
"    _method = method\n"
"  }\n"
"\n"
"//  classMirror { Mirror.reflect(MethodMirror.class_(_method)) }\n"
"  moduleMirror { ModuleMirror.fromModule_(MethodMirror.module_(_method)) }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(_class)\n"
"    var methods = attr != null ? attr.methods : null\n"
"    return methods != null ? methods[signature] : null\n"
"  }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static fromModule_(module) {\n"
"    return ModuleMirror.new_(module)\n"
"  }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return ModuleMirror.fromModule_(module)\n"
"  }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"\n"
"class StackTrace {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"    for (i in 0...stackFramesCount) {\n"
"      _stackTrace.add(StackTraceFrame.new_(fiber, i))\n"
"    }\n"
"  }\n"
"  \n"
"  static new(fiber) {\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(fiber)\n"
"\n"
"    return new_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  frames { _stackTrace }\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(fiber, stackFramesIndex) {\n"
"    _line = FiberMirror.lineAt_(fiber, stackFramesIndex)\n"
"    _methodMirror = MethodMirror.new_(FiberMirror.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { _line }\n"
"  methodMirror { _methodMirror }\n"
"\n"
"  // toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"  toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((97..122).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((65..90).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"}\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

